"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[477],{10:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"simplify-fp-crud","metadata":{"permalink":"/blog/simplify-fp-crud","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2024-03-09-simplifying-functional-crud-route.md","source":"@site/blog/2024-03-09-simplifying-functional-crud-route.md","title":"Simplifying a functional crud route","description":"Most larger applications eventually solve three problems:","date":"2024-03-09T00:00:00.000Z","formattedDate":"March 9, 2024","tags":[],"readingTime":14.615,"hasTruncateMarker":false,"authors":[],"frontMatter":{"slug":"simplify-fp-crud","title":"Simplifying a functional crud route"},"unlisted":false},"content":"Most larger applications eventually solve three problems:\\n1. Raising errors that need to be handled.\\n2. Handling lists of data as opposed to single entities.\\n3. Optionally calling apis, depending on input.\\n\\nTo exemplify what issues may arrise when dealing with such problems, we will create an list of entities by performing some operations for each entity:\\n1. Parse the input\'s phone number ([as opposed to validating](https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/)).\\n2. Reading the relevant organization for the request from the database, raising an error if the organization is not found.\\n3. Construct the resulting entities, by fetching an access token from the database and calling a remote api to create them in the external system.\\n4. Insert the resulting entities into the database.\\n\\n## Motivation\\nWhen using by-the-book functional programming tools to perform the tasks at hand the code quickly grows unwieldy.\\nBy applying more exotic functional abstractions, we can simplify the code and make it more extensible.\\n\\n\\n## Domain\\nConsider the following prelude to illustrate the issue at hand.\\n```scala\\nfinal case class InputUser(\\n  name: String,\\n  age: Int,\\n  phone: String,\\n  shouldBeCreatedInApi: Boolean\\n)\\n\\nfinal case class Organization(\\n  id: UUID,\\n  name: String\\n)\\n\\nfinal case class Phone(value: String)\\ndef parsePhone(phone: String): Either[String, Phone] = ???\\n\\nfinal case class User(\\n  id: UUID,\\n  name: String,\\n  age: Int,\\n  phone: Phone,\\n  api: Option[Int],\\n  organization: UUID\\n)\\n\\nfinal case class CreateUser(name: String, phone: Phone)\\ntrait UserApi {\\n  // returns the ids of the created users\\n  def createUsers(token: String, inputs: NonEmptyList[CreateUser]): IO[NonEmptyList[Int]]\\n}\\n\\ntrait Repo {\\n  def insertUser(user: NonEmptyList[User]): IO[Unit]\\n  def getOrganization(id: UUID): IO[Option[Organization]]\\n  def getOrganizationAccessToken(id: UUID): IO[String]\\n}\\n\\nsealed trait Error\\nfinal case class PhoneParseError(message: String) extends Throwable with Error {\\n  override def getMessage: String = message\\n}\\n\\nfinal case class OrganizationNotFound() extends Throwable with Error {\\n  override def getMessage: String = s\\"Organization not found\\"\\n}\\n```\\nWith the domain in place, we can start to explore how we can satisfy the requirements for our API.\\n\\n## The initial implementation\\nWe\'ll start off with a crude and complex implementation to set the stage.\\n```scala\\ndef insertUsers(\\n  organizationId: UUID,\\n  inputs: NonEmptyList[InputUser],\\n  api: UserApi,\\n  repo: Repo\\n): IO[Either[Error, NonEmptyList[UUID]]] = {\\n  val run: IO[NonEmptyList[UUID]] = \\n    for {\\n      withPhone <- inputs.traverse{ iu =>\\n        IO.fromEither(parsePhone(iu.phone).leftMap(PhoneParseError(_))).map(x => (iu, x))\\n      }\\n      _ <- repo.getOrganization(organizationId).flatMap{\\n        case None => IO.raiseError(OrganizationNotFound())\\n        case Some(_) => IO.unit\\n      }\\n\\n      usersThatNeedToBeCreated = withPhone.filter{ case (iu, _) => iu.shouldBeCreatedInApi }\\n\\n      withApiIds <- usersThatNeedToBeCreated\\n        .toNel\\n        .toList\\n        .flatTraverse { nel =>\\n          repo.getOrganizationAccessToken(organizationId).flatMap{ token =>\\n            val creates = nel.map{ case (iu, phone) => CreateUser(iu.name, phone) }\\n            api.createUsers(token, creates).map(_.zip(nel)).map(_.toList)\\n          }\\n        }\\n\\n      createdUsers = withApiIds.map{ case (apiId, (iu, phone)) => (iu, phone, Some(apiId)) }\\n      nonCreatedUsers = withPhone\\n        .collect{ case (iu, phone) if !(iu.shouldBeCreatedInApi) => (iu, phone, Option.empty[Int]) }\\n\\n      users <- (createdUsers ++ nonCreatedUsers).traverse { case (iu, phone, apiId) =>\\n        UUIDGen.randomUUID[IO].map(id => User(id, iu.name, iu.age, phone, apiId, organizationId))\\n      }\\n      _ <- users.toNel.traverse_(xs => repo.insertUser(xs))\\n    } yield users.map(_.id).toNel.get\\n\\n  run.map(Right(_)).recover{ case e: Error => Left(e) }\\n}\\n```\\nThe initial implementation has some issues, some of which are syntatic and others semantic.\\n1. (syntax) We pay a steep price in terms of complexity for batching api operations.\\n2. (semantics) Errors are not accumulated, the first error that occurs \\"wins\\".\\n3. (syntax) If more steps are added then the tuple of data we pass around will grow.\\n4. (semantics) Any intermediate exception handlers may eat our error since it is a exception.\\n5. (syntax) Partitioning the inputs into two groups is not a pleasant experience and scales poorly with more groups.\\n\\nWe will first address the correctness of our solution, and then we will address the syntactic issues.\\n## Functional error handling\\nThe classic answer to high-level error handling when effects are involved in functional programming are monad transformers.\\nAlthough this won\'t be our final destination, adding a monad transformer as an intermediate stepping stone in our refactoring will help us understand the problem better.\\n```scala\\ndef insertUsers(\\n  organizationId: UUID,\\n  inputs: NonEmptyList[InputUser],\\n  api: UserApi,\\n  repo: Repo\\n): IO[Either[Error, NonEmptyList[UUID]]] = {\\n  type G[A] = EitherT[IO, Error, A]\\n  val G = MonadError[G, Error]\\n  val liftK: IO ~> G = EitherT.liftK[IO, Error]\\n  val run: G[NonEmptyList[UUID]] = \\n    for {\\n      withPhone <- inputs.traverse{ iu =>\\n        G.fromEither(parsePhone(iu.phone).leftMap(PhoneParseError(_))).map(x => (iu, x))\\n      }\\n      _ <- liftK(repo.getOrganization(organizationId)).flatMap{\\n        case None => G.raiseError[Unit](OrganizationNotFound())\\n        case Some(_) => G.unit\\n      }\\n\\n      usersThatNeedToBeCreated = withPhone.filter{ case (iu, _) => iu.shouldBeCreatedInApi }\\n\\n      withApiIds <- liftK {\\n        usersThatNeedToBeCreated\\n          .toNel\\n          .toList\\n          .flatTraverse { nel =>\\n            repo.getOrganizationAccessToken(organizationId).flatMap{ token =>\\n              val creates = nel.map{ case (iu, phone) => CreateUser(iu.name, phone) }\\n              api.createUsers(token, creates).map(_.zip(nel)).map(_.toList)\\n            }\\n          }\\n      }\\n\\n      createdUsers = withApiIds.map{ case (apiId, (iu, phone)) => (iu, phone, Some(apiId)) }\\n      nonCreatedUsers = withPhone\\n        .collect{ case (iu, phone) if !(iu.shouldBeCreatedInApi) => (iu, phone, Option.empty[Int]) }\\n\\n      users <- liftK {\\n        (createdUsers ++ nonCreatedUsers).traverse { case (iu, phone, apiId) =>\\n          UUIDGen.randomUUID[IO].map(id => User(id, iu.name, iu.age, phone, apiId, organizationId))\\n        }\\n      }\\n      _ <- liftK(users.toNel.traverse_(xs => repo.insertUser(xs)))\\n    } yield users.map(_.id).toNel.get\\n\\n  run.value\\n}\\n```\\nWith the addition of `EitherT` we have alleviated the 4th concern, but with the unfortunate side effect of making the code more complex.\\nBefore handling `EitherT`, let\'s take a look at another issue.\\n## Accumulating errors\\nMonads are inherently sequential, and as such, they are not well suited for accumulating errors.\\nInstead, we are looking for an algebraic structure that allows independent operations to be combined.\\nTo solve this riddle, we\'ll invite `Applicative` to the war table.\\n`Either` has an accumulating cousin called `Validated` that forms an `Applicative` if the error `E` forms a `Semigroup`.\\n`cats` gives some useful type aliases for `Validated`, notably `ValidatedNec` which has the following definition:\\n```scala\\ntype ValidatedNec[E, A] = Validated[NonEmptyChain[E], A]\\n```\\nSince `NonEmptyChain` forms a `Semigroup` (it has a lawful combine function), then we have our `Applicative`.\\n\\nWriting out the code (or reading it for that matter) with `Validated` is not going to be a pleasant experience.\\nIt will involve a bunch of values of type `IO[ValidatedNec[Error, A]]` which all require a bunch of `sequence`ing to wire together.\\nInstead, bear with me, we can introduce another typeclass that will help us out.\\n\\n`cats` distills the relationship for structures that have `Applicative` or `Monad` semantics into a typeclass `Parallel`.\\n\\n`Parallel` for structures `F` and `G` implies that we know:\\n* `F ~> G`\\n* `G ~> F`\\n* `Applicative[G]`\\n* `Monad[F]`\\n\\n`Parallel` does not neccessarily mean parallel execution, but rather the ability to switch to a different context for intermediate operations.\\n`Parallel` defines the realtionship between `Either` and `Validated` for some type `E` if `E` forms a `Semigroup`:\\n* `Either[E, *] ~> Validated[E, *]` by `toValidated`\\n* `Validated[E, *] ~> Either[E, *]` by `toEither`\\n* `Applicative[Validated[E, *]]` since `E` forms a `Semigroup`\\n* `Monad[Either[E, *]]` by construction\\n\\nNow for the application of the above discussion.\\nOur `EitherT` also has a `Parallel` instance that allows us to accumulate errors.\\nLets introduce a new error type that contains a non-empty collection of errors instead.\\n```scala\\ntype Errors = NonEmptyChain[Error]\\n```\\nWe\'ll use `parTraverse` instead of `traverse` when parsing the phone numbers.\\n:::info\\n`parTraverse` does the same as `traverse` but uses the `Applicative` inside of `Parallel` to sequence the effects:\\n1. given a fuction `A => F[B]`, switch `F` to `G` via `F ~> G` such that `A => G[B]`\\n2. use `G`\'s `Applicative` to sequence the results such that `G[T[B]]` for some `Traverse[T]`\\n3. switches back to `F` via `G ~> F` such that `F[T[B]]`.\\n:::\\n```scala\\ndef insertUsers(\\n  organizationId: UUID,\\n  inputs: NonEmptyList[InputUser],\\n  api: UserApi,\\n  repo: Repo\\n): IO[Either[Errors, NonEmptyList[UUID]]] = {\\n  type G[A] = EitherT[IO, Errors, A]\\n  val G = MonadError[G, Errors]\\n  val liftK: IO ~> G = EitherT.liftK[IO, Errors]\\n  implicit val parallelG: Parallel[G] = EitherT.accumulatingParallel[IO, Errors]\\n  val run: G[NonEmptyList[UUID]] = \\n    for {\\n      withPhone <- inputs.parTraverse{ iu =>\\n        G.fromEither {\\n          parsePhone(iu.phone).leftMap(x => NonEmptyChain.one(PhoneParseError(x)))\\n        }.map(x => (iu, x))\\n      }\\n      _ <- liftK(repo.getOrganization(organizationId)).flatMap{\\n        case None => G.raiseError[Unit](NonEmptyChain.one(OrganizationNotFound()))\\n        case Some(_) => G.unit\\n      }\\n\\n      usersThatNeedToBeCreated = withPhone.filter{ case (iu, _) => iu.shouldBeCreatedInApi }\\n\\n      withApiIds <- liftK {\\n        usersThatNeedToBeCreated\\n          .toNel\\n          .toList\\n          .flatTraverse { nel =>\\n            repo.getOrganizationAccessToken(organizationId).flatMap{ token =>\\n              val creates = nel.map{ case (iu, phone) => CreateUser(iu.name, phone) }\\n              api.createUsers(token, creates).map(_.zip(nel)).map(_.toList)\\n            }\\n          }\\n      }\\n\\n      createdUsers = withApiIds.map{ case (apiId, (iu, phone)) => (iu, phone, Some(apiId)) }\\n      nonCreatedUsers = withPhone\\n        .collect{ case (iu, phone) if !(iu.shouldBeCreatedInApi) => (iu, phone, Option.empty[Int]) }\\n\\n      users <- liftK {\\n        (createdUsers ++ nonCreatedUsers).traverse { case (iu, phone, apiId) =>\\n          UUIDGen.randomUUID[IO].map(id => User(id, iu.name, iu.age, phone, apiId, organizationId))\\n        }\\n      }\\n      _ <- liftK(users.toNel.traverse_(xs => repo.insertUser(xs)))\\n    } yield users.map(_.id).toNel.get\\n\\n  run.value\\n}\\n```\\nThis solves issue 2.\\nThere is a lot of considerations behind our parallel instance.\\nA `Parallel` inastance for `EitherT` is not a free lunch, it comes with ambiguity.\\nMultiple valid `Parallel` instances for `EitherT` exist, but that is another topic.\\n\\nWith this addition we have solved all issues regarding semantics.\\nNow we can take try to make the solution syntactically more pleasing.\\n\\n## Handling batching\\nWe pay a hefty price for batching, since we have to manually partition our batches and handle the case where there are no elements in the batch.\\n\\nSay we would like to solve our batching issue once and for all.\\nBy exploring commonplace batching libraries, one would quickly find that most use global state and timers.\\nSolving problems algebraically as opposed to heuristically, is something functional programmers should be good at.\\n[Haxl](https://dl.acm.org/doi/10.1145/2628136.2628144) is an optimistic algebraic solution for batching.\\n\\nHaxl is a library for Haskell, but implementations for Scala also exist.\\n* [Fetch](https://github.com/xebia-functional/fetch) is a library that is close to Haxl and has a plentyful collection of utilities.\\n* [Hxl](https://github.com/casehubdk/hxl) is a small (pure) library that focuses on the core of Haxl and extensibility whilst being algebraically correct.\\n* [ZQuery](https://github.com/zio/zio-query) is a library that that also provides a Haxl-like experience, being it is built on top of `ZIO`, it is not as typeclass focused but instead leans heavily into `ZIO`.\\n\\nSince this post is about simplifying and using well considered algebraic principles, we will be using `Hxl`.\\n\\n:::info\\nHaxl is optimistic since it assumes (hopes) that every instance of a data source fetch is the same number of flatMaps away from the root.\\nIf the number of flatMaps is indeterministic then Haxl may produce poor batches:\\n```scala\\nfetchA.flatMap{ _ =>\\n  if (randomBoolean()) Hxl.unit.flatMap(_ => fetchB)\\n  else fetchB\\n}\\n```\\n:::\\n\\nTo allow batching we must lift our batched api into `Hxl`.\\nAs in the Haxl paper, we must define datasources for our apis.\\n```scala\\nfinal case class InsertUserKey(user: User)\\ncase object InsertUser extends DSKey[InsertUserKey, Unit]\\n\\ndef insertUserDataSource(repo: Repo): DataSource[IO, InsertUserKey, Unit] = \\n  DataSource.void(InsertUser) { (keys: NonEmptyList[InsertUserKey]) =>\\n    repo.insertUser(keys.map(_.user)).void\\n  }\\n\\ndef insertUser(user: User, repo: Repo): Hxl[IO, Unit] =\\n  Hxl(InsertUserKey(user), insertUserDataSource(repo)).void\\n\\nfinal case class CreateUsersKey(users: CreateUser)\\nobject CreateUsersKey {\\n  implicit val show: Show[CreateUsersKey] = Show.fromToString\\n}\\nfinal case class CreateUsers(token: String) extends DSKey[CreateUsersKey, Int]\\n\\ndef createUserDataSource(token: String, api: UserApi): DataSource[IO, CreateUsersKey, Int] = \\n  DataSource.from(CreateUsers(token)) { (keys: NonEmptyList[CreateUsersKey]) =>\\n    api.createUsers(token, keys.map(_.users)).map{ results =>\\n      keys.zip(results).toList.toMap\\n    }\\n  }\\n\\ndef createUser(input: CreateUser, token: String, api: UserApi): Hxl[IO, Int] =\\n  Hxl.force(CreateUsersKey(input), createUserDataSource(token, api))\\n```\\n\\n`Hxl` only forms an `Applicative`, but we need `flatMap` to express our program.\\n`Hxl` provides `andThen` (like `Validated`) and a `Monad`ic view `HxlM`, like `Either` is to `Validated`.\\n\\nBefore the next iteration, note that we only need to load the token if we have at least one user that needs to be created in the api.\\nWe can use `Hxl` to load the token exactly once.\\nBut not all tasks need to be solved with the same tool, if a simpler one is available.\\nWe can look towards memoization to lazily load the token.\\n\\n`Hxl`, by default, does only provide an `Applicative` instance.\\nHowever, we can import a `Parallel` instance for `HxlM` which will let us combine the resulting `Hxl`s in parallel if our effect type also forms a `Parallel`.\\n\\nNow we can express our batching a tad more elegantly.\\n```scala\\ndef insertUsers(\\n  organizationId: UUID,\\n  inputs: NonEmptyList[InputUser],\\n  api: UserApi,\\n  repo: Repo\\n): IO[Either[Errors, NonEmptyList[UUID]]] = {\\n  type G[A] = EitherT[IO, Errors, A]\\n  val G = MonadError[G, Errors]\\n  val liftK: IO ~> G = EitherT.liftK[IO, Errors]\\n  implicit val parallelG: Parallel[G] = EitherT.accumulatingParallel[IO, Errors]\\n  import hxl.instances.hxlm.parallel._\\n  def run(input: InputUser, getToken: IO[String]): HxlM[G, UUID] = \\n    for {\\n      phone <- HxlM.liftF {\\n        G.fromEither(parsePhone(input.phone).leftMap(x => NonEmptyChain.one(PhoneParseError(x))))\\n      }\\n      tokOpt <- HxlM.liftF(liftK(getToken)).map(_.some.filter(_ => input.shouldBeCreatedInApi))\\n      apiId <- tokOpt.traverse(createUser(CreateUser(input.name, phone), _, api)).mapK(liftK).monadic\\n      id <- HxlM.liftF(UUIDGen.randomUUID[G])\\n      u = User(id, input.name, input.age, phone, apiId, organizationId)\\n      _ <- insertUser(u, repo).mapK(liftK).monadic\\n    } yield id\\n\\n  val ga = for {\\n    _ <- liftK(repo.getOrganization(organizationId)).flatMap{\\n      case None => G.raiseError[Unit](NonEmptyChain.one(OrganizationNotFound()))\\n      case Some(_) => G.unit\\n    }\\n    getToken <- liftK(repo.getOrganizationAccessToken(organizationId).memoize)\\n    // notice we run in parallel (parTraverse) to use our accumulating parallel instance\\n    res <- Hxl.runSequential(inputs.parTraverse(iu => run(iu, getToken)).hxl)\\n  } yield res\\n\\n  ga.value\\n}\\n```\\nThe code is now a lot shorter and we can use closures (flatMap) to express our program.\\nWe solved issue 1 and 5 with `Hxl`.\\n\\n## Erasing `EitherT`\\nA lot of the code\'s remaining complexity is due to our use of `EitherT`.\\nPulling in a tool to algebraically solve a problem will yet again be our salvation.\\n\\nA capability based utility named [catch-effect](https://github.com/ValdemarGr/catch-effect) that I have authored will aid us in this task.\\n`catch-effect` allows us to write as if using MTL, but without the need for monad transformers.\\n`catch-effect` provides a structure `Catch` that can open local scopes where errors can be raised and caught:\\n```scala\\ndef example(c: Catch[IO]): IO[Either[Error, String]] =\\n  c.use[Error] { (h: Handle[IO, Error]) =>\\n    h.raise(PhoneParseError(\\"error\\")) *> IO(\\"I will never happen\\")\\n  }\\n```\\n\\nLet us take a step back and relax our accumulating errors constraint for the next iteration.\\n```scala\\ndef insertUsers(\\n  organizationId: UUID,\\n  inputs: NonEmptyList[InputUser],\\n  api: UserApi,\\n  repo: Repo,\\n  c: Catch[IO]\\n): IO[Either[Error, NonEmptyList[UUID]]] = c.use[Error] { h =>\\n  def run(input: InputUser, getToken: IO[String]): HxlM[IO, UUID] = \\n    for {\\n      phone <- HxlM.liftF {\\n        h.fromEither(parsePhone(input.phone).leftMap(x => PhoneParseError(x)))\\n      }\\n      tokOpt <- HxlM.liftF(getToken).map(_.some.filter(_ => input.shouldBeCreatedInApi))\\n      apiId <- tokOpt.traverse(createUser(CreateUser(input.name, phone), _, api)).monadic\\n      id <- HxlM.liftF(UUIDGen.randomUUID[IO])\\n      u = User(id, input.name, input.age, phone, apiId, organizationId)\\n      _ <- insertUser(u, repo).monadic\\n    } yield id\\n\\n  for {\\n    _ <- h.fromOptionF(OrganizationNotFound())(repo.getOrganization(organizationId))\\n    getToken <- repo.getOrganizationAccessToken(organizationId).memoize\\n    res <- Hxl.runSequential(inputs.traverse(iu => run(iu, getToken).hxl))\\n  } yield res\\n}\\n```\\n\\nNow let\'s restore our wish for accumulating errors.\\n\\nWhen we worked with `EitherT`, we had to pick a `Parallel` instance for `EitherT` that would accumulate errors.\\nThe default `Parallel` instance for `IO` will for any two effects, run their effects as two parallel fibers.\\n`IO`, however, cannot reason with errors from `catch-effect`.\\nFortunately `catch-effect` can construct a `Parallel` accumulating instance for `IO` (given that `E` forms a `Semigroup`), just like `EitherT`!.\\nWhen we slam all of our `Hxl`s together, we will do so in parallel, using the enchanced `Parallel` instance from `catch-effect`.\\n```scala\\ndef insertUsers(\\n  organizationId: UUID,\\n  inputs: NonEmptyList[InputUser],\\n  api: UserApi,\\n  repo: Repo,\\n  c: Catch[IO]\\n): IO[Either[Errors, NonEmptyList[UUID]]] = c.use[Errors] { h =>\\n  implicit val parallel: Parallel[HxlM[IO, *]] = \\n    hxl.instances.hxlm.parallel.parallelHxlMForParallelEffect(h.accumulatingParallelForParallel)\\n  def run(input: InputUser, getToken: IO[String]): HxlM[IO, UUID] = \\n    for {\\n      phone <- HxlM.liftF {\\n        h.fromEither(parsePhone(input.phone).leftMap(x => NonEmptyChain.one(PhoneParseError(x))))\\n      }\\n      tokOpt <- HxlM.liftF(getToken).map(_.some.filter(_ => input.shouldBeCreatedInApi))\\n      apiId <- tokOpt.traverse(createUser(CreateUser(input.name, phone), _, api)).monadic\\n      id <- HxlM.liftF(UUIDGen.randomUUID[IO])\\n      u = User(id, input.name, input.age, phone, apiId, organizationId)\\n      _ <- insertUser(u, repo).monadic\\n    } yield id\\n\\n  for {\\n    _ <- h.fromOptionF(NonEmptyChain.one(OrganizationNotFound())) { \\n      repo.getOrganization(organizationId)\\n    }\\n    getToken <- repo.getOrganizationAccessToken(organizationId).memoize\\n    res <- Hxl.runSequential(inputs.parTraverse(iu => run(iu, getToken)).hxl)\\n  } yield res\\n}\\n```\\n\\nAnd that\'s it.\\nWe went though a lot of stuff, but we ended up with a much shorter solution.\\nThe data sources we created can also be reused in other parts of our application.\\n\\n## Conclusion\\nThe line-of-code reduction between the first semantically correct solution and the final one was not negligible, but we had to add extra abstractions to get there.\\n\\nThe final solution requires more knowledge of the generic abstractions, and reduces the required problem-specific knowledge for readers of the code.\\nHowever the initial solution is easier for someone who is not familiar with the abstractions to understand.\\n\\nIf an abstraction has a foundational nature, is principled and practical, then I believe it is worth the effort to learn.\\n\\nOur interest in the relationship between `Monad` and `Applicative` is of foundational nature, the interest in dependent and independent things.\\n`Parallel` is an abstraction that lets us reason with structures that can be given multiple semantics, some of which form a `Monad` and some of which form an `Applicative`.\\n\\n`Hxl` is a principled solution to batching, however it is more of an engineering solution than a mathematical construction.\\nRegardless, `Hxl` almost cuts the problem size in half and is generally applicable.\\n\\n`catch-effect` introduces algebras (MTL) that are well established in functional programming.\\n`catch-effect` is a pragmatic solution born from modern effect research of algebraic effects and capabilities.\\nHowever, `catch-effect` is the only abstraction that we have explored which cannot be graced with a sound api (capture checking).\\n\\nUnfortunately, ambiguity is involved in picking the right `Parallel` instance, be it `EitherT` or `IO` with `catch-effect`.\\nI suppose the nature of `Parallel` is reasoning with ambiguity, being that `Parallel` instances for monad transformers are sometimes defined by another `Parallel` instance.\\nConsider this table for ambigious semantics for `IO` (or `EitherT` for that matter):\\n\\n| IO  | IO with error E1 |\\n|-----|------------------|\\n| Par | Par              |\\n| Par | Seq              |\\n| Seq | Par              |\\n\\nThere is no unique `Parallel` definition for `IO` anymore.\\nNow what happens if we introduce another error?\\n\\n| IO  | IO with error E1 | IO with error E2 |\\n|-----|------------------|------------------|\\n| Par | Par              | Seq              |\\n| Par | Seq              | Seq              |\\n| Seq | Par              | Seq              |\\n| Par | Par              | Par              |\\n| Par | Seq              | Par              |\\n| Seq | Par              | Par              |\\n\\nIn fact, the choices grow by $2^n$ where $n$ is the number of error channels.\\n\\nThank you for reading, I hope that at least some of the ideas and abstractions presented in this post were of interest."}]}')}}]);